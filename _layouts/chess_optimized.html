<!DOCTYPE html>
<html lang="{{ page.language }}">

<head>
  {% include head.html %}
  <!-- Optimized: External CSS for better performance and maintainability -->
  <link rel="stylesheet" href="/assets/css/chess.css">
  
  <!-- Preload critical resources -->
  <link rel="preload" href="/assets/js/chess.js" as="script">
  
  <!-- Meta tags for better SEO and social sharing -->
  <meta name="description" content="KC Gaming Chess - æ ¡å†…å›½é™…è±¡æ£‹ç«èµ›å¹³å°ï¼ŒåŒ…å«E.C.ç³»åˆ—ã€PRO LEAGUEå’ŒChampionsèµ›äº‹">
  <meta property="og:title" content="KC Gaming Chess">
  <meta property="og:description" content="åº·æ¡¥å­¦æ ¡å›½é™…è±¡æ£‹ç«èµ›å¹³å°">
  <meta property="og:type" content="website">
</head>

<body>
  <!-- Header -->
  <header class="header" role="banner">
    <div class="header-content">
      <nav class="back-link" aria-label="è¿”å›å¯¼èˆª">
        <a href="/">â† è¿”å›é¦–é¡µ</a>
      </nav>
      <h1>KC Gaming <span>Chess</span></h1>
      <div style="width: 80px;" aria-hidden="true"></div> <!-- Spacer for centering -->
    </div>
  </header>

  <!-- Main Container -->
  <div class="container">
    <!-- Two Column Layout -->
    <div class="content-wrapper">
      <!-- Left Main Content -->
      <main class="main-content" role="main">
        <!-- Quick Info Card -->
        <section class="quick-info-card" id="quickInfoCard" aria-labelledby="quickInfoTitle">
          <header class="quick-info-header">
            <span class="quick-info-icon" aria-hidden="true">âš¡</span>
            <h2 id="quickInfoTitle">è¿‘æœŸæ¯”èµ›</h2>
          </header>
          <div class="quick-info-content" id="quickInfoContent">
            <div class="quick-info-loading" role="status" aria-live="polite">åŠ è½½ä¸­...</div>
          </div>
        </section>

        <!-- Password Banner -->
        <aside class="password-banner" role="complementary" aria-label="æ¯”èµ›å¯†ç ">
          <div class="password-banner-content">
            <div class="password-banner-title">ğŸ”‘ æ¯”èµ›å¯†ç </div>
            <div class="password-banner-text">æ‰€æœ‰æ¯”èµ›ä½¿ç”¨ç›¸åŒå¯†ç ï¼Œç‚¹å‡»å¤åˆ¶</div>
            <div class="password-display">
              <code id="passwordCode" aria-label="æ¯”èµ›å¯†ç ">KangChiaoInternationalSchool</code>
              <button class="copy-btn" onclick="window.chessApp.copyPassword()" type="button" aria-label="å¤åˆ¶å¯†ç ">å¤åˆ¶</button>
            </div>
          </div>
        </aside>

        <!-- Collapsible Rules -->
        <section class="rules-toggle" aria-labelledby="rulesTitle">
          <header class="rules-header" onclick="window.chessApp.toggleRules()" role="button" tabindex="0" 
            onkeypress="if(event.key==='Enter'||event.key===' '){window.chessApp.toggleRules();event.preventDefault();}"
            aria-expanded="false" aria-controls="rulesContent">
            <h2 id="rulesTitle">ğŸ“‹ æ¯”èµ›è§„åˆ™</h2>
            <span class="rules-icon" id="rulesIcon" aria-hidden="true">â–¼</span>
          </header>
          <div class="rules-content" id="rulesContent" role="region" aria-labelledby="rulesTitle">
            {{ site.data.chess.rules | markdownify }}
          </div>
        </section>
      </main>

      <!-- Right Sidebar -->
      <aside class="sidebar-content" role="complementary" aria-label="LiChess TVç›´æ’­">
        <div class="lichess-tv-container">
          <header class="lichess-tv-header">
            <h2>ğŸ¬ çƒ­é—¨å¯¹å±€</h2>
            <p>LiChess TV ç›´æ’­</p>
          </header>
          <div class="lichess-tv-frame">
            <iframe
              src="https://lichess.org/tv/frame?theme=brown&bg=dark"
              style="width: 100%; aspect-ratio: 10/11; border-radius: 10px;"
              allowtransparency="true"
              frameborder="0"
              title="LiChess TVç›´æ’­"
              loading="lazy"></iframe>
          </div>
        </div>
      </aside>
    </div>

    <!-- Timeline -->
    <section class="timeline" id="matchesTimeline" role="region" aria-label="æ¯”èµ›æ—¶é—´è½´">
      <!-- Dynamically generated by JavaScript -->
    </section>
  </div>

  <!-- External JavaScript -->
  <script src="/assets/js/main.js"></script>
  <script src="/assets/js/chess.js"></script>
  
  <!-- Inline Script for Jekyll Data Rendering -->
  <script>
    (function() {
      'use strict';
      console.log('Loading chess data from Jekyll...');
      
      try {
        // Series definitions from YAML
        const recurringSeries = {
          {% for series in site.data.chess.recurring_series %}
          {{ series.id | jsonify }}: {
            nameTemplate: {{ series.name_template | jsonify }},
            displayName: {{ series.display_name | default: series.id | jsonify }},
            icon: {{ series.icon | default: "" | jsonify }},
            frequency: {{ series.frequency | jsonify }},
            dayOfWeek: {{ series.day_of_week | jsonify }},
            startTime: {{ series.start_time | jsonify }},
            durationHours: {{ series.duration_hours | jsonify }},
            prizes: [
              {% if series.prize_distribution %}
                {% for prize in series.prize_distribution %}
                { position: {{ prize.position | jsonify }}, amount: {{ prize.amount | jsonify }} }{% unless forloop.last %},{% endunless %}
                {% endfor %}
              {% endif %}
            ]
          }{% unless forloop.last %},{% endunless %}
          {% endfor %}
        };
      
        // Match instances from YAML
        const rawMatches = [
          {% for match in site.data.chess.matches %}
          {
            {% if match.series_id %}
            seriesId: {{ match.series_id | jsonify }},
            season: {{ match.season | jsonify }},
            date: {{ match.date | jsonify }},
            {% else %}
            name: {{ match.name | jsonify }},
            startTime: {{ match.start_time | jsonify }},
            endTime: {{ match.end_time | jsonify }},
            special_type: {{ match.special_type | jsonify }},
            special_icon: {{ match.special_icon | default: "" | jsonify }},
            description: {{ match.description | jsonify }},
            prizes: [
              {% if match.prize_distribution %}
                {% for prize in match.prize_distribution %}
                { position: {{ prize.position | jsonify }}, amount: {{ prize.amount | jsonify }} }{% unless forloop.last %},{% endunless %}
                {% endfor %}
              {% endif %}
            ],
            {% endif %}
            link: {{ match.link | jsonify }},
            winners: [
              {% if match.winner %}
                {% for winner in match.winner %}
                { position: {{ winner.position | jsonify }}, name: {{ winner.name | jsonify }} }{% unless forloop.last %},{% endunless %}
                {% endfor %}
              {% endif %}
            ]
          }{% unless forloop.last %},{% endunless %}
          {% endfor %}
        ];
      
        // Build complete match list
        const matches = rawMatches.map(match => {
          if (match.seriesId && recurringSeries[match.seriesId]) {
            const series = recurringSeries[match.seriesId];
            const matchDate = new Date(match.date);
            const [startHour, startMinute] = series.startTime.split(':').map(Number);
            
            const startTime = new Date(matchDate);
            startTime.setHours(startHour, startMinute, 0);
            
            const endTime = new Date(startTime);
            endTime.setHours(endTime.getHours() + Math.floor(series.durationHours));
            endTime.setMinutes(endTime.getMinutes() + (series.durationHours % 1) * 60);
            
            const pad = n => String(n).padStart(2, '0');
            const formatLocalTime = (date) => {
              return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
            };
            
            let name = series.nameTemplate.replace('{season}', match.season);
            name = name.replace('{month}', (matchDate.getMonth() + 1) + 'æœˆ');
            
            return {
              name: name,
              startTime: formatLocalTime(startTime),
              endTime: formatLocalTime(endTime),
              link: match.link,
              seriesId: match.seriesId,
              seriesName: series.displayName || match.seriesId,
              prizes: Array.isArray(series.prizes) ? series.prizes : [],
              winners: Array.isArray(match.winners) ? match.winners : []
            };
          } else {
            return Object.assign({}, match, {
              prizes: Array.isArray(match.prizes) ? match.prizes : [],
              winners: Array.isArray(match.winners) ? match.winners : []
            });
          }
        });
      
        console.log('Matches loaded:', matches.length);
        
        // Save to global
        window.chessApp.globalMatches = matches;
        globalMatches = matches; // Backward compatibility
        
        if (matches.length === 0) {
          document.getElementById('matchesTimeline').innerHTML = `
            <div class="empty-state">
              <div class="empty-state-icon">â™Ÿï¸</div>
              <p>æš‚æ— æ¯”èµ›å®‰æ’</p>
            </div>
          `;
          return;
        }
      
        const now = new Date();
        const timeline = document.getElementById('matchesTimeline');
        
        // Categorize matches
        const running = [];
        const upcoming = [];
        const past = [];
        
        matches.forEach(match => {
          const startTime = window.chessApp.parseMatchDate(match.startTime);
          const endTime = window.chessApp.parseMatchDate(match.endTime);
          if (endTime < now) {
            past.push(match);
          } else if (startTime <= now && now < endTime) {
            running.push(match);
          } else {
            upcoming.push(match);
          }
        });
        
        // Sort
        upcoming.sort((a, b) => window.chessApp.parseMatchDate(a.startTime) - window.chessApp.parseMatchDate(b.startTime));
        past.sort((a, b) => window.chessApp.parseMatchDate(b.startTime) - window.chessApp.parseMatchDate(a.startTime));
        
        // Render running matches
        if (running.length > 0) {
          const runningGroup = document.createElement('div');
          runningGroup.className = 'time-group running-group';
          runningGroup.innerHTML = '<div class="time-label">ğŸ”´ æ­£åœ¨è¿›è¡Œ</div>';
          
          running.forEach(match => {
            const matchItemDiv = document.createElement('div');
            matchItemDiv.innerHTML = window.chessApp.createMatchCard(match, false);
            runningGroup.appendChild(matchItemDiv.firstElementChild);
          });
          
          timeline.appendChild(runningGroup);
        }
        
        // Render upcoming matches
        if (upcoming.length > 0) {
          const upcomingGroup = document.createElement('div');
          upcomingGroup.className = 'time-group';
          upcomingGroup.innerHTML = '<div class="time-label">âš¡ å³å°†å¼€å§‹</div>';
        
          const seriesMatches = new Map();
          upcoming.forEach(match => {
            if (match.seriesId) {
              if (!seriesMatches.has(match.seriesId)) {
                seriesMatches.set(match.seriesId, []);
              }
              seriesMatches.get(match.seriesId).push(match);
            }
          });
        
          const renderedSeries = new Set();
        
          upcoming.forEach(match => {
            if (match.seriesId) {
              if (renderedSeries.has(match.seriesId)) {
                return;
              }
        
              const groupMatches = seriesMatches.get(match.seriesId) || [];
              const extras = groupMatches.slice(1);
              const toggleId = `series-extra-${match.seriesId}`;
              const seriesLabel = match.seriesName || (recurringSeries[match.seriesId]?.displayName) || match.seriesId.toUpperCase();
              const seriesIcon = recurringSeries[match.seriesId]?.icon || '';
        
              const cardOptions = extras.length > 0 ? {
                hasExtras: true,
                toggleId: toggleId,
                seriesLabel: seriesLabel,
                extrasCount: extras.length,
                seriesIcon: seriesIcon
              } : {
                seriesIcon: seriesIcon
              };
              
              const matchItemDiv = document.createElement('div');
              matchItemDiv.innerHTML = window.chessApp.createMatchCard(match, false, cardOptions);
              upcomingGroup.appendChild(matchItemDiv.firstElementChild);
        
              if (extras.length > 0) {
                const extrasContainer = document.createElement('div');
                extrasContainer.id = toggleId;
                extrasContainer.className = 'series-extra hidden';
                extras.forEach(extraMatch => {
                  const extraDiv = document.createElement('div');
                  extraDiv.innerHTML = window.chessApp.createMatchCard(extraMatch, false);
                  extrasContainer.appendChild(extraDiv.firstElementChild);
                });
                upcomingGroup.appendChild(extrasContainer);
              }
        
              renderedSeries.add(match.seriesId);
              return;
            }
        
            const specialIcon = match.special_icon || '';
            const matchItemDiv = document.createElement('div');
            matchItemDiv.innerHTML = window.chessApp.createMatchCard(match, false, { seriesIcon: specialIcon });
            upcomingGroup.appendChild(matchItemDiv.firstElementChild);
          });
          
          timeline.appendChild(upcomingGroup);
        }
        
        // Render past matches with leaderboard
        if (past.length > 0) {
          const seriesLabelMap = {
            ec: (recurringSeries['ec']?.displayName || 'E.C.'),
            pro: (recurringSeries['pro']?.displayName || 'PRO LEAGUE'),
            champions: (recurringSeries['champions']?.displayName || 'Champions')
          };

          const basePoints = { first: 10, second: 6, third: 4 };
          const multiplier = { ec: 1, pro: 2, champions: 3 };

          const countsWins = { all: new Map(), ec: new Map(), pro: new Map(), champions: new Map() };
          const points = { all: new Map(), ec: new Map(), pro: new Map(), champions: new Map() };

          const norm = (s) => (s || '').trim().replace(/\s+/g, ' ');

          past.forEach(m => {
            const key = window.chessApp.getSeriesKey(m);
            if (key === 'other' || m.special_type === 'special') return;
            const winners = Array.isArray(m.winners) ? m.winners : [];
            const w1 = winners.find(w => /ğŸ¥‡|ç¬¬ä¸€/.test(w.position || ''));
            const w2 = winners.find(w => /ğŸ¥ˆ|ç¬¬äºŒ/.test(w.position || ''));
            const w3 = winners.find(w => /ğŸ¥‰|ç¬¬ä¸‰/.test(w.position || ''));

            if (w1 && w1.name) {
              const name = norm(w1.name);
              countsWins.all.set(name, (countsWins.all.get(name) || 0) + 1);
              if (countsWins[key]) countsWins[key].set(name, (countsWins[key].get(name) || 0) + 1);
            }

            const addP = (winner, posKey) => {
              if (!winner || !winner.name) return;
              const name = norm(winner.name);
              const add = (basePoints[posKey] || 0) * (multiplier[key] || 1);
              if (add <= 0) return;
              points.all.set(name, (points.all.get(name) || 0) + add);
              if (points[key]) points[key].set(name, (points[key].get(name) || 0) + add);
            };
            addP(w1, 'first');
            addP(w2, 'second');
            addP(w3, 'third');
          });

          const pastGroup = document.createElement('div');
          pastGroup.className = 'time-group';
          pastGroup.innerHTML = '<div class="time-label">ğŸ† å·²ç»“æŸ</div>';

          const rule = document.createElement('div');
          rule.className = 'rule-card';
          rule.innerHTML = `
            <h4>ğŸ¯ è®¡åˆ†è§„åˆ™</h4>
            <ul>
              <li>ä»…ç»Ÿè®¡ E.C. / PRO LEAGUE / Champions ä¸‰å¤§ç³»åˆ—ï¼Œç‰¹æ®Šèµ›äº‹ä¸å‚ä¸ç§¯åˆ†ã€‚</li>
              <li>åŸºç¡€åˆ†ï¼ˆE.C.ï¼‰ï¼šğŸ¥‡10åˆ†ã€ğŸ¥ˆ6åˆ†ã€ğŸ¥‰4åˆ†ã€‚</li>
              <li>ç³»åˆ—åŠ æƒï¼šPRO Ã—2ï¼›Champions Ã—3ï¼ˆä¾‹å¦‚ï¼šChampions ğŸ¥‡=30åˆ†ï¼‰ã€‚</li>
              <li>èƒœåœºæ¦œï¼šæŒ‰ã€ŒğŸ¥‡ç¬¬ä¸€åæ¬¡æ•°ã€æ’åï¼ˆä¸ç§¯åˆ†æ— å…³ï¼‰ã€‚</li>
              <li>åç§°æŒ‰æŠ¥ååå•åŸæ ·ç»Ÿè®¡ï¼Œè‹¥éœ€åˆå¹¶åŒä¸€é€‰æ‰‹ä¸åŒå†™æ³•ï¼Œè¯·ç»Ÿä¸€å§“åã€‚</li>
            </ul>
          `;
          pastGroup.appendChild(rule);

          const availableSeries = ['all', 'ec', 'pro', 'champions'].filter(k => k === 'all' || countsWins[k].size > 0 || points[k].size > 0);

          const modeHtml = `
            <div class="leaderboard-modes">
              <button class="mode-tab active" data-mode="points" type="button">ç§¯åˆ†æ¦œ</button>
              <button class="mode-tab" data-mode="wins" type="button">èƒœåœºæ¦œ</button>
            </div>
          `;

          const tabsHtml = availableSeries.map((k, i) => {
            const label = k === 'all' ? 'å…¨éƒ¨' : seriesLabelMap[k] || k.toUpperCase();
            const active = i === 0 ? 'active' : '';
            return `<button class="leaderboard-tab ${active}" data-series="${k}" type="button">${label}</button>`;
          }).join('');

          const buildList = (map, unit) => {
            const arr = Array.from(map.entries()).sort((a, b) => b[1] - a[1]).slice(0, 10);
            return arr.map(([name, c], idx) => {
              const rankIcon = idx === 0 ? 'ğŸ¥‡' : idx === 1 ? 'ğŸ¥ˆ' : idx === 2 ? 'ğŸ¥‰' : (idx + 1);
              const value = unit === 'pts' ? `${c}` : `${c}`;
              const escapedName = name.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
              return `<div class="leaderboard-item"><div class="lb-rank">${rankIcon}</div><div class="lb-name">${escapedName}</div><div class="lb-count">${value}</div></div>`;
            }).join('') || '<div style="color:#b8c5d1; font-size:0.9em;">æš‚æ— æ•°æ®</div>';
          };

          const pointsListsHtml = availableSeries.map((k, i) => {
            const active = i === 0 ? 'active' : '';
            return `<div class="leaderboard-list ${active}" data-mode="points" data-series="${k}">${buildList(points[k], 'pts')}</div>`;
          }).join('');
          
          const winsListsHtml = availableSeries.map((k) => {
            return `<div class="leaderboard-list" data-mode="wins" data-series="${k}">${buildList(countsWins[k], 'wins')}</div>`;
          }).join('');

          const leaderboard = document.createElement('div');
          leaderboard.className = 'leaderboard-section';
          leaderboard.innerHTML = `
            <div class="leaderboard-title">ğŸ… æ’è¡Œï¼ˆå¯åˆ‡æ¢æ¨¡å¼ï¼‰</div>
            ${modeHtml}
            <div class="leaderboard-tabs">${tabsHtml}</div>
            ${pointsListsHtml}
            ${winsListsHtml}
          `;
          pastGroup.appendChild(leaderboard);

          const grid = document.createElement('div');
          grid.className = 'past-grid';
          past.forEach(match => {
            const card = document.createElement('div');
            card.innerHTML = window.chessApp.createPastCard(match);
            grid.appendChild(card.firstElementChild);
          });
          pastGroup.appendChild(grid);

          timeline.appendChild(pastGroup);

          // Bind mode and series switching
          const switchTo = (mode, series) => {
            pastGroup.querySelectorAll('.mode-tab').forEach(b => b.classList.toggle('active', b.getAttribute('data-mode') === mode));
            pastGroup.querySelectorAll('.leaderboard-tab').forEach(b => b.classList.toggle('active', b.getAttribute('data-series') === series));
            pastGroup.querySelectorAll('.leaderboard-list').forEach(list => {
              const ok = list.getAttribute('data-mode') === mode && list.getAttribute('data-series') === series;
              list.classList.toggle('active', ok);
            });
          };

          let currentMode = 'points';
          let currentSeries = availableSeries[0] || 'all';
          switchTo(currentMode, currentSeries);

          pastGroup.querySelectorAll('.mode-tab').forEach(btn => {
            btn.addEventListener('click', () => {
              currentMode = btn.getAttribute('data-mode');
              switchTo(currentMode, currentSeries);
            });
          });

          pastGroup.querySelectorAll('.leaderboard-tab').forEach(btn => {
            btn.addEventListener('click', () => {
              currentSeries = btn.getAttribute('data-series');
              switchTo(currentMode, currentSeries);
            });
          });
        }
        
        console.log('Timeline rendering complete');
        
      } catch (error) {
        console.error('Error rendering timeline:', error);
        document.getElementById('matchesTimeline').innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">âš ï¸</div>
            <p>åŠ è½½æ¯”èµ›æ•°æ®æ—¶å‡ºé”™</p>
            <p style="font-size: 0.85em; color: #888;">${error.message}</p>
          </div>
        `;
      }
    })();
    
    // Load optional UI functions
    try {
      if (typeof load_switch_language_btn === 'function') {
        load_switch_language_btn('{{ page.language }}');
      }
      if (typeof load_ui_toggle_btn === 'function') {
        load_ui_toggle_btn('{{ page.language }}');
      }
      if (typeof bind_onclick_btn === 'function') {
        bind_onclick_btn();
      }
    } catch (e) {
      console.log('Optional UI functions not available:', e);
    }
  </script>
</body>

</html>
